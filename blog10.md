# My Experience with Haskell
## Blog 10

When I first started the Programming Languages class, and found out we would be using Haskell, I didn't know what to expect.
In the past, I have coded mostly in imperative coding languages like Java, C# and C++. So when I was told that Haskell would be completely different, I was scared.
And it was difficult, I won't say that it wasn't. There were a lot of points over the last couple months that I struggled, and had to work really hard.

After struggling with setting up Haskell and BNFC, which I wrote about in my first blog. I started to get the hang of Haskell, but struggled with the basic grammar.
So I ended up doing a lot of research, and compiled notes on basic Haskell grammar, some of which I also shared in earlier blogs. From there, we went on to build a basic
calculator in Haskell. This was my first real test.

The first thing I had to make sure I understood was Haskell's native number system. I was able to grasp the concept of natural numbers represented by S and O, but struggled more with positive numbers, represented by T and I.
If T and I were both equal to 1, why do you use both. The answer lies in the fact that the system needs a base case, and it need a way to distinguish where a number ends. Although numbers exist below 1, positive numbers cannot go below 1 by definition.
So when Haskell takes in number inputs, The use of I tells the system that when it reaches I, it has reached the final 1 and therefore the number is finished. Otherwise I was able to grasp the basics of building a calultor in Haskell, since I have
a coding background so the semantics of telling a computer how to do certain mathematical functions is familiar to me.

From there, the next part of Haskell I struggled with the Discrete mathematics. I have never taken a discrete mathematics course, so I felt very lost when we first starting using it while learning Haskell.
Similarly to how I struggled to transition from imperative languages to Haskell, I struggled with changing my thinking from concrete to discrete mathematics. Similar to the issue I had with positive numbers, I
found myself constantly asking "why" something was the way it was. But what helped me overcome that, and what I continued to remind myself was that there didn't always have to be a "why". Discrete mathematics is abstract,
which means that it didn't always have to make complete sense to be useful. Instead, I started asking "how". I focused on learning how discrete mathematics worked, and how it worked in relation to Haskell. From there, it was easier for
me to grasp and I started to pick it up more quickly.

The other big struggle I wanted to talk about was taking on new syntax. In each major assignment, I found myself faced with writing that was unique from most of what I had seen and used before.
But learning by example was really useful. I used what I was provided, mixed with what I knew about Haskell, and coding languages in general, and was able to translate my methods into these new syntactic forms.
Particularly in the third assignment, when we were working with a whole new programming language LambdaFun, I found myself getting things mixed up. I wanted to write in the formatting that I had used in past assignments,
but I knew that it wouldn't work the same in this new language. But I think the benefit of learning Haskell is that it made me think outside of the box, and made it easier for my to see patterns in coding languages that allow me to pick it up quicker.

All in all, this language was difficult for me to learn, but I believe it has helped me understand the fundamentals of a lot of coding languages I have learned in the past. And hopefully it will help me in the future with learning new languages. 
